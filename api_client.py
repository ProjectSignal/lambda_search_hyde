"""HTTP client for interacting with the search state API from the HyDE service."""

from typing import Any, Dict, Optional, Sequence

import requests

from config import (
    SEARCH_API_BASE_URL,
    SEARCH_API_KEY,
    SEARCH_API_TIMEOUT,
)
from logging_config import setup_logger

logger = setup_logger(__name__)


class SearchServiceError(RuntimeError):
    """Raised when the upstream search service reports an error."""


def _build_headers() -> Dict[str, str]:
    """Construct default headers for the outbound API call."""
    headers = {"Content-Type": "application/json"}
    if SEARCH_API_KEY:
        headers["x-api-key"] = SEARCH_API_KEY
    return headers


def _parse_response(response: requests.Response) -> Dict[str, Any]:
    try:
        payload = response.json()
    except ValueError:  # pragma: no cover - defensive guard for non-JSON responses
        payload = {}

    if isinstance(payload, dict) and "data" in payload:
        return payload["data"]
    return payload


def get_search_document(search_id: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve the persisted search document for a given search identifier.

    Input: ``search_id`` (str) – unique identifier generated by searchInitializer.
    Output: Dict representing the search document when it exists, otherwise ``None``.
    """
    url = f"{SEARCH_API_BASE_URL}/search/{search_id}"
    try:
        response = requests.get(url, headers=_build_headers(), timeout=SEARCH_API_TIMEOUT)
    except requests.RequestException as exc:  # pragma: no cover - network failure guard
        raise SearchServiceError(f"Failed to retrieve search {search_id}: {exc}") from exc

    if response.status_code == 404:
        logger.info("Search document %s not found via API", search_id)
        return None
    if not response.ok:
        raise SearchServiceError(
            f"Search service returned {response.status_code} while fetching {search_id}: {response.text}"
        )
    return _parse_response(response)


def create_search_document(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Persist a brand-new search execution document.

    Input: ``payload`` dict mirroring the search document schema expected by the platform.
    Output: Dict describing the created entity as returned by the upstream API.
    """
    url = f"{SEARCH_API_BASE_URL}/search"
    try:
        response = requests.post(
            url,
            json=payload,
            headers=_build_headers(),
            timeout=SEARCH_API_TIMEOUT,
        )
    except requests.RequestException as exc:  # pragma: no cover
        raise SearchServiceError(f"Failed to create search document: {exc}") from exc

    if not response.ok:
        raise SearchServiceError(
            f"Search service returned {response.status_code} while creating document: {response.text}"
        )
    return _parse_response(response)


def get_user_document(user_id: str) -> Optional[Dict[str, Any]]:
    """
    Fetch user metadata needed for authentication flows.

    Input: ``user_id`` (str) – identifier of the user to resolve.
    Output: Dict describing the user when found, otherwise ``None`` when API responds with 404.
    """
    url = f"{SEARCH_API_BASE_URL}/users/{user_id}"
    try:
        response = requests.get(url, headers=_build_headers(), timeout=SEARCH_API_TIMEOUT)
    except requests.RequestException as exc:  # pragma: no cover
        raise SearchServiceError(f"Failed to retrieve user {user_id}: {exc}") from exc

    if response.status_code == 404:
        return None
    if not response.ok:
        raise SearchServiceError(
            f"Search service returned {response.status_code} while fetching user {user_id}: {response.text}"
        )
    return _parse_response(response)


def delete_search_document(search_id: str) -> None:
    """
    Remove a test search document, primarily used by local validation scripts.

    Input: ``search_id`` (str) – identifier to delete. Output: ``None`` on success.
    """
    url = f"{SEARCH_API_BASE_URL}/search/{search_id}"
    try:
        response = requests.delete(url, headers=_build_headers(), timeout=SEARCH_API_TIMEOUT)
    except requests.RequestException as exc:  # pragma: no cover
        raise SearchServiceError(f"Failed to delete search {search_id}: {exc}") from exc

    if response.status_code in (200, 202, 204, 404):
        # Treat missing document as a no-op for idempotent cleanup
        return
    raise SearchServiceError(
        f"Search service returned {response.status_code} while deleting {search_id}: {response.text}"
    )


def update_search_document(
    search_id: str,
    *,
    set_fields: Optional[Dict[str, Any]] = None,
    append_events: Optional[Sequence[Dict[str, Any]]] = None,
    expected_statuses: Optional[Sequence[str]] = None,
) -> Dict[str, Any]:
    """
    Apply partial updates to an existing search document.

    Input:
        ``search_id`` – identifier of the document to update.
        ``set_fields`` – dict of fields that should be overwritten/merged.
        ``append_events`` – iterable of event payloads appended to the document's timeline.
        ``expected_statuses`` – optional list of allowed current statuses that must match upstream state.
    Output: Dict representing the updated search document snapshot returned by the API.
    """
    payload: Dict[str, Any] = {}
    if set_fields:
        payload["set"] = set_fields
    if append_events:
        payload["appendEvents"] = list(append_events)
    if expected_statuses:
        payload["expectedStatus"] = list(expected_statuses)

    url = f"{SEARCH_API_BASE_URL}/search/{search_id}"
    try:
        response = requests.patch(
            url,
            json=payload,
            headers=_build_headers(),
            timeout=SEARCH_API_TIMEOUT,
        )
    except requests.RequestException as exc:  # pragma: no cover
        raise SearchServiceError(f"Failed to update search {search_id}: {exc}") from exc

    if response.status_code == 404:
        raise SearchServiceError(f"Search document {search_id} not found during update")
    if not response.ok:
        raise SearchServiceError(
            f"Search service returned {response.status_code} while updating {search_id}: {response.text}"
        )

    return _parse_response(response)
